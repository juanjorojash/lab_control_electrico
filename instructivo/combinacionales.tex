\chapter{Programación de funciones combinacionales.}

\section{Objetivos}
Este es un laboratorio introductorio que busca:
\begin{itemize}
	{\small
	 \item  Programar funciones booleanas combinacionales en Arduino.
	 \item  Verificar la compuertas NAND y NOR son en si mismas un conjunto Universal, equivalentes a el conjunto de conectivas lógicas OR, AND y NOT.
	\item  	Verificar que a partir de los mintérminos de una expresión lógica se obtienen los circuitos con compuertas NAND y de los maxtérminos, los circuitos con compuertas NOR.
	\item  Verificar que para obtener la solución mínima de un circuito lógico, es necesario sintetizar los circuitos tanto por mintérminos como por maxtérminos. 
	\item Programar multiplexores $4\times1$, $8\times1$.
	\item Programar un DECOdificador Binario a Decimal.
 }
\end{itemize} 


\section{Equipos y materiales}
Para este laboratorio de necesitaran:
\begin{itemize} 
	{\small \item 1 Arduino UNO o equivalente: MEGA o ESP32.
	\item 1 Multímetro.
	\item 10 Resistencias de 270 o 330 $\Omega$.
	\item 5 Resistencias de 1k$\Omega$.
	\item 10 interruptores pulsadores.
	\item 1 Protoboard.
	\item 10 Diodes emisor de luz (LEDs).
	\item 1 Computadora portátil.}
\end{itemize}

\section{Marco de referencia}

Un circuito combinacional digital es un circuito que produce una o varias salidas en función de sus entradas actuales. Es decir, no mantiene ningún estado interno y su salida depende exclusivamente de sus entradas en el momento actual.
Existen muchas formas de implementar circuitos combinacionales, a partir de contactos eléctricos, válvulas neumáticas, transistores, software, etc. Sin embargo cualquier circuito lógico combinacional se puede expresar mediante cuatro formas equivalentes que describen su funcionamiento: ecuación lógica, tabla de verdad, diagrama de tiempo, y circuito eléctrico. 
Puede encontrar información adicional en el siguiente enlace \href{https://es.wikipedia.org/wiki/Sistema_combinacional}{https://es.wikipedia.org/wiki/Sistema\_combinacional}.   

\subsection{Implementan de expresiones Booleanas }

Un circuito combinacional  puede ser representado de distintas formas, pero la más común es mediante una ecuación lógica, por ejemplo: 
\begin{equation}
\label{Ec1}
F(a,b,c)=ab+\bar{a}\bar{b}c
\end{equation}

La expresión anterior posee una representación en suma de productos (SDP), puede ser implementada en C de la siguiente forma:

		 \begin{lstlisting}[language=Arduino,numbers=none, showstringspaces=false]
		bool F(bool a,bool b,bool c){
			return  a&&b||!a&&!b&&c;
		}
		\end{lstlisting} 

Existen ocho formas estándar de implementar la ecuación \eqref{Ec1} digital-mente y por consecuencia en software . Otras maneras de implementar las funciones lógicas  son con el producto de sumas (PDS), las implementaciones a dos niveles  NAND/NAND y NOR/NOR, todas las implementaciones deben arrojar los mismos resultados.

Por otra parte, la ecuación \eqref{Ec1} es equivalente a la expresión booleana  NAND/NAND si se niega dos veces y se aplica el \href{https://es.wikipedia.org/wiki/Leyes_de_De_Morgan}{Teorema de Morgan}.


\begin{eqnarray}
\label{Ec2}
F(a,b,c)=ab+\bar{a}\bar{b}c \\
F(a,b,c)=\overline{\overline{ab+\bar{a}\bar{b}c }} \\  \label{Ec3}
F(a,b,c)=\overline{\overline{ab}\cdot\overline{\bar{a}\bar{b}c}}
\end{eqnarray}


Notece que la ecuacion \eqref{Ec3} necesita conectivas lógicas (funciones) de 2 y 3 entradas. Esto no es un problema cuando se implementa en SOFTWARE, pero sí se requiere hacer una implementación fisica hay que aplicar el Algebra Booleana para dejar la expresión en términos de conectivas de solamente dos entradas. Lo que se hace es que el término de tres literales, le aplicamos una doble negación tal como sigue.

\begin{eqnarray}
\label{Ec5}
F(a,b,c)=\overline{\overline{ab}\cdot\overline{\overline{\overline{\bar{a}\bar{b}}}\cdot c}} 
\end{eqnarray}

La expresión \eqref{Ec5} se encuentra en términos de conectivas NAND de dos entradas y se puede implementar en ARDUINO  de la siguiente forma:
{\footnotesize 
\begin{lstlisting}[language=Arduino,numbers=none, showstringspaces=false]
bool F(bool a, bool b, bool c){
	bool resul = false;
	resul = NAND(NAND(a,b),NAND(NAND(NAND(NAND(a,true),NAND(b,true)),true),c));
	return resul;
}
\end{lstlisting} 
}
donde la NAND de dos entradas es:

		\begin{lstlisting}[language=Arduino,numbers=none, showstringspaces=false]
		bool NAND(bool x, bool y){
			return !(x && y);
		}
		\end{lstlisting}

\subsection{Multiplexores y Decodificadores}

Un \href{https://es.wikipedia.org/wiki/Multiplexor}{multiplexor} (Mux) es un circuito combinacional con $2^{n}$ entrada, más $n$  entradas selectoras o de control y una salida. Este circuito combinacional selecciona con las $n$ entradas control,  el valor booleano de una entrada entre $\left[ 0,2^{n}-1\right]$ y coloca dicho valor en la salida. La ecuación general de cualquier multiplexor es la siguiente,

\begin{equation}
MUX=\sum_{i=0}^{2^{n}-1} I_{i}\cdot \mathbb{S}_i
\end{equation}
donde $\mathbb{S}_i$  es la $i$-ésima permutacion de las entradas de selección. A modo de ejemplo un Mux $2 \times 1$
 posee dos entradas digitales y una de control y una salida. Un Mux $4 \times 1$ posee cuatro entradas digitales más dos de control y una salida, Un Mux $8 \times 1$ posee ocho entradas digitales más tres de control y una salida.
 
La ecuación de un Mux $4 \times 1$ es la siguiente,

\begin{equation}
	F(I_0,I_1,I_2,I_3,S_0,S_1)=I_0\bar{S_1}\bar{S_0}+I_1\bar{S_1}S_0+I_2S_1\bar{S_0}+I_3S_1S_0  \;\; .
\end{equation} El código para implementar dicho multiplexor es similar al siguiente,
{\footnotesize 
\begin{lstlisting}[language=Arduino,numbers=none, showstringspaces=false]
bool F(bool I0,bool I1,bool I2,bool I3,bool S1,bool S0){
	return (I0&&!S1&&!S0 || I1&&!S1&&S0 || I1&&S1&&!S0 || I3&&S1&&S0) ;
}
\end{lstlisting}
}
Los circuitos que realizan función inversa del multiplexor se  llama \href{https://es.wikipedia.org/wiki/Demultiplexor}{Demultiplexores}  y usualmente tiene una entrada digital más $n$ entradas de selección y $2^{n}$ salidas digitales.

Otro ejemplo de circuito combinacional son los \href{URL}{Decodificadores} y \href{https://es.wikipedia.org/wiki/Codificador}{Codificadores}.  Un codificador es un circuito combinacional con $2^{n}$ entradas y $n$ salidas, cuya misión es presentar en la salida el código binario correspondiente a la entrada activada. Mientras que un decodificador hace el trabajo inverso, recibe un código binario y lo transforma en cualquier otro código, ya sea  binarios como el Gray o exceso 3; o otras reprentaciones numericas: octal, decimal, hexagecimal. La figura \ref{fig:decoderexample} muestra la implementan digital de un decodificador de 2 a 4 líneas, la tabla de verdad del circuito y las ecuaciones características de cada salida. 
\begin{figure}
	\centering
	\includegraphics[width=0.7\linewidth]{fig/Decoder_Example.png}
	\caption{Decodificador de código binario de dos bits a cuatro líneas de salida.  }
	\label{fig:decoderexample}
\end{figure}

Una posible implementación para Arduino de este decodificador es la siguiente.

\begin{lstlisting}[language=Arduino,numbers=none, showstringspaces=false]
	byte  DECO (bool A0, bool A1)
	{
		int i=0;
		bool D[4]={false, false, false, false};
		byte deco=0;
	
		D[0]=!A1&&!A0;
		D[1]=!A1&&A0;
		D[2]=A1&&!A0;
		D[3]=A1&&A0;
	
		for (i=0; i<sizeof(D);i++)
		{
			bitWrite(deco, i, D[i]);
		}
	return deco;
	}
\end{lstlisting}
  
\section{Metodología}

Este laboratorio tiene una duración de 4 lecciones, repartidas en dos semanas. Los estudiantes deben mostrar durante las clases programadas las tres actividades propuestas. Deben recabar fotografías y resultados de los equipos de medición para elaborar las evidencias. Las evidencias se subirán al TecDigital la semana siguiente finalizadas las actividades.

\section{Práctica en Clase}

\subsection{Actividad 1}

Programe en Arruino una lógica combinacional que resuelva el siguiente problema.  En una planta industrial se desea automatizar un motor y una alarma de acuerdo a 4 sensores llamados a, b, c, d.  La señal del motor se representa por la función lógica f1, y se validará  cuando el sensor  a y b estén activos, o cuando  este b y  este el sensor d o cuando estén a, c y d. Por otro lado, la señal de  alarma (función f2), se activa siempre que estén todos los sensores apagados excepto a o todos apagados excepto c o  estén c y d encendidos y el resto apagados. También la alarma se encienden cuando todos los sensores son activados o cuando estén todos excepto d o todos excepto c.
 
 En el Arduino los Pines $\left\lbrace 0,1,2,3\right\rbrace $ serán las entradas digitales {a,b,c,d}. Las salidas o respuestas de las funciones se dividen en dos grupos, los pines $\left\lbrace 5,6,7\right\rbrace $ se reservan para f1. Se deben implementar tres funciones:  la suma de productos (SDP), el producto de suma(PDS) y la funcion resuelta por conectivas NAND/NAND.   Por otro lado la función f2  mostrar\'{a} su respuesta mediante los pines 
 $\left\lbrace 8,9,10\right\rbrace $, dicha función es implementada mediante SDP, PDS y conectivas NOR/NOR.
 
 
\subsubsection{Conteste las preguntas:}

¿Cómo sería el circuito digital de cada una de las funciones implementadas?
¿Como es la tabla de verdad experimental de cada salida versus la tabla teórica?


\subsection{Actividad 2}

Programe las funciones de un Multiplexor 2x1, 4x1 y 8x1.
Por otra parte, existe un circuito  combinacional que se comporta como la siguiente tabla de verdad. Cuadro \eqref{tab:tv}.

\begin{table}[H]
\centering
\caption{Comportamiento esperado de la estructura lógica.}
\label{tab:tv}
\begin{tabular}{|c|c|c|}

	\hline 
	a 	& b  & $F(a,b)$  \\ 
	\hline 
 	0	& 0 &  $c + d$\\ 

	0	& 1 &  $\overline{c + d}$\\ 

	1	& 0 &  $\overline{c \cdot d}$\\ 

	1	& 1 &  $c \oplus d$\\ 
	\hline 
\end{tabular} 

\end{table}

\subsubsection{Conteste las preguntas:}

¿El comportamiento de un multiplicador $8 \times 1$ coincide con la tabla teórica?
En la funcion Loop() , llame la función del MUX  $8 \times 1$ e ingrese parámetros $\left\lbrace a,b,c,d \right\rbrace $ de tal forma que se comporte igual que la tabla de verdad presentada en el Cuadro \ref{tab:tv}.¿Tiene el mismo comportamiento?
¿Es posible implementar la T.V. con dos MUX $4 \time 1$ y un MUX  $2 \time 1$?¿Como se implementa?

\subsection{Actividad 3}

Implemente en un Arduino un decodificador de 3 bits a Octal. En otro Arduino programe la función de un codificador Octal a binario de 3 bit. Conecte ambos Arduinos, las entradas del primer arduino se conectan a botoneras, las salidas del primer arduino se conectan con las entradas del segundo Arduino y las salidas del segundo Arduino se conectan a LEDs.  


\subsubsection{Conteste las preguntas:} 
¿La tabla de verdad del codificador es idéntica a la teórica o esperada?
¿La tabla de verdad del decodificador es idéntica a la teórica o esperada?
¿Como es la salida del segundo Arduino respecto a las entradas del primero?
